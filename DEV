
                             BIT Development Notes

                                      ***

                   Here we wrote all the technical questions
                   and solutions that we use in development.


                                       1.
                                 Using Date(s)

1.1 Problem (A)

    When using date we have many options based on Date, Date + Time and
    Timezone. We need to decide whether use Date or Date + Time, and a Timezone
    is a core question indeed. Found problems:

        • As we do not know the client side local settings, as we do not know
        the client side timezone, it's better to use timezone aware date format
        at server side. But using dates its hard to tell the timezone.

    In Rust using Chrono.rs we have the following date types:

            - Date<Offset>
            - DateTime<Offset>
            - NaiveDate
            - NaiveDateTime

    As for the Offset we can use Local or Fixed offset, or Utc.

    Using UTC seems to be a good choice as in this case we can properly handle
    time zones.

1.2 Problem (B)

    Using Utc for DateTime sounds good. But what can we do with single dates
    without time information? There can be situation where there are no time
    information. Can we use or should we use timezone in this case?

    E.g. at BIT we have date_settlement field at each transaction. In
    bookkeeping for the date_settlement we generally do not use time zones
    as each bill/invoice has its own date in its own locale. But managing it
    without timezone can also be confusing. What if a team member register a
    transaction from Japan to our Hungarian books? And what if that person
    register a Hungarian bill from Japan?
        
1.3 Solution (A)

    RFC3339

    This ISO standard can be used as as common Date format. It contains a Naive
    DateTime plus an offset, or a Z sign to display it's in UTC. The offset is
    the offset from UTC.

    Example RFC3339

        2020-03-05T13:07:56+00:00
        2020-03-05T13:07:56Z

    Using JavaScript Date() has a built in method to generate RFC3339 format.
    It's called toISOString() and it produces the date format as UTC based on
    the locale settings.

    Example:

        new Date().toISOString()

    Suggested solution workflow:

        1.  We store date as DateTime<Utc> at server side
        2.  At client side we use Date as date type, and working with dates as
            ilocal dates
        3.  We transform client JS side Date to ISOString() and send the data
            model to the server
        4.  At server side we accept date as String and convert them to RFC3339
            format at the beginning. + validation!
        5.  Store date in UTC, automatically converted from client side locale
            date

        Workflow diagram

        [CLIENT]                             [Server]
          |                                     |
          |---- Request: Date (RFC3339) ---->  API --> Store in DateTime<Utc>


1.4 Solution (B)

    For now we avoid using time zones for this particular field
    (date_settlement) and just use NaiveDate and locale Date string from client
    side.

    For a more sophisticated solution we should somehow use TimeZone aware date
    type, but we also should manage the business logic to handle time zones. As
    in the Problem (B) part we somehow should be able to set the timezone to
    each date: locale time zone to the Japanese bill accounting it from Japan,
    and the Hungarian time zone to the Hungarian bill accounting it from Japan,
    but this could be confusing.

    At this point - in the project - we do not have the required knowledge and
    market need for this solution.


                                       2.
                                  Data storage


2.1 Issue

    Storing data is key from both technical and business side. Core questions to
    choose the right technology:

    * How big is the data we plan to use
      
      Do we have maximum a few MB of plain data, or we have GB or petabytes of
      them? Can we store memory first? And use a storage just as a data store? I
      mean using it in memory, all the data lookups and manipulation, and store
      all the data change in a storage? Bot for read operations using just the
      memory?

    * Is it read or write heavy?

      How fast should it be? Do we need many concurrent read operations and a
      few write one; or it mainly many writes and a few reads, or we have
      constantly both many read and write operations in the same time? Who has
      time to wait? The reader or writer?

      One thing is sure: we should have zero data race.

    * How fast response time we need?

      Do we need a fast response in 10-40 millisec or even faster? Do we need it
      even for thousands of concurrent requests? Do we have concurrency and
      parallel requests or do we have a queue?

    * Do we have platform dependence?

      Any Microsoft, Apple, or Linux platform dependence? Does it need to be
      operational on both platforms? Maybe do we use it on both of them in the
      same time? Do we have any ecosystem dependence that predestinate the
      platform dependence that we have? e.g.: mssql for Microsoft

    * Do we need to plan scaling?

      Do we have an estimated constant size date in range of 0-10 MB? Or do we
      have the same situation but with a few GB of data? Or do we have an
      unknown size of data with an unknown size of scale?

    * And how fast and big we need to scale up?

      Do we need to count on using multiple instance of the same time with load
      balancers? Or its enough to use a single instance and scale it up?
      Do we need vertical or horizontal scaling as well?

    * Data security, backups.

      How frequenlty we need backups? And how big is the backup?

    * Resource need to data storage.

      Do we need to store everything in memory? If yes, we is it economical to
      store everything in memory? Do we need that performance? Can we scale to
      split data into memory and not-memory stored? So for extra low response
      time use memory and using not memory storage for the other type for
      requests?

    * Learning curve of the data storage technology.

      What background we have, technical and HR capabilities? What is our growth
      strategy? The data technology determines our future advantage and
      disadvantage as well. e.g.: using Microsoft related data technology
      determines the team and their expertise as well. Using plain text
      technology with in-memory operations using C or C++ also determines all
      the benefits and threaths and fears.
    
________________________

Appendix

    Unicode's
    
        In this project I use sometimes Unicode characters. Here you can find
        the used
        
        characters and their codes:
    
        •   => 2022
        ⭐  => eb50
        😍  => 1f60d
